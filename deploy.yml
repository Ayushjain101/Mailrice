---
# Mailserver Automated Deployment Playbook
# Usage: ansible-playbook -i inventory deploy.yml --extra-vars "domain=yourdomain.com hostname=mail.yourdomain.com"

- name: Deploy Custom Mail Server
  hosts: mailserver
  become: yes
  vars:
    # Override these with --extra-vars
    domain: "{{ domain }}"
    hostname: "{{ hostname }}"
    db_name: mailserver
    db_user: mailserver
    api_port: 3000
    vmail_uid: 5000
    vmail_gid: 5000
    # Cloudflare credentials (optional) - provide via --extra-vars for DNS automation
    cf_email: "{{ cf_email | default('') }}"
    cf_api_key: "{{ cf_api_key | default('') }}"
    cf_zone_id: "{{ cf_zone_id | default('') }}"

  pre_tasks:
    # ========== PRE-FLIGHT VALIDATION (Phase 1 - V2 Stabalisation) ==========
    - name: "[PRE-FLIGHT] Display validation start"
      debug:
        msg: |
          ========================================
          PRE-FLIGHT VALIDATION
          ========================================
          Checking system requirements...

    - name: "[PRE-FLIGHT] Check system memory (minimum 2GB required, 4GB recommended)"
      assert:
        that:
          - ansible_memtotal_mb >= 2048
        fail_msg: |
          INSUFFICIENT MEMORY

          Minimum Required: 2GB (2048 MB)
          Current Available: {{ ansible_memtotal_mb }} MB
          Recommended: 4GB (4096 MB)

          Mail server requires at least 2GB RAM for stable operation.
          Please upgrade your server resources before deployment.
        success_msg: "✓ Memory check passed: {{ ansible_memtotal_mb }} MB available"

    - name: "[PRE-FLIGHT] Check disk space (minimum 10GB required)"
      assert:
        that:
          - item.size_available > 10737418240  # 10GB in bytes
        fail_msg: |
          INSUFFICIENT DISK SPACE

          Minimum Required: 10GB
          Current Available: {{ (item.size_available / 1024 / 1024 / 1024) | round(2) }} GB on {{ item.mount }}

          Mail server requires at least 10GB for:
          - System packages and dependencies
          - Mail storage (/var/vmail)
          - Database files
          - Log files

          Please free up disk space or use a larger volume.
        success_msg: "✓ Disk space check passed: {{ (item.size_available / 1024 / 1024 / 1024) | round(2) }} GB available on {{ item.mount }}"
      loop: "{{ ansible_mounts }}"
      when: item.mount == '/'

    - name: "[PRE-FLIGHT] Validate hostname format"
      assert:
        that:
          - hostname is match('^[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?(\.[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)*$')
          - hostname is match('.*\..*')  # Must contain at least one dot (FQDN)
        fail_msg: |
          INVALID HOSTNAME FORMAT

          Provided: {{ hostname }}

          Requirements:
          - Must be a valid FQDN (e.g., mail.example.com)
          - Only lowercase letters, numbers, dots, and hyphens allowed
          - Must contain at least one dot
          - Cannot start or end with a hyphen
          - Maximum 253 characters

          Examples:
          ✓ mail.example.com
          ✓ smtp.my-domain.org
          ✗ localhost
          ✗ MAIL.EXAMPLE.COM (uppercase not allowed)
          ✗ -invalid-.com
        success_msg: "✓ Hostname format valid: {{ hostname }}"

    - name: "[PRE-FLIGHT] Validate domain format"
      assert:
        that:
          - domain is match('^[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?(\.[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)*$')
          - domain is match('.*\..*')  # Must contain at least one dot
        fail_msg: |
          INVALID DOMAIN FORMAT

          Provided: {{ domain }}

          Requirements:
          - Must be a valid domain (e.g., example.com)
          - Only lowercase letters, numbers, dots, and hyphens allowed
          - Must contain at least one dot
          - Cannot start or end with a hyphen

          Examples:
          ✓ example.com
          ✓ my-domain.org
          ✗ example (no TLD)
          ✗ EXAMPLE.COM (uppercase not allowed)
        success_msg: "✓ Domain format valid: {{ domain }}"

    - name: "[PRE-FLIGHT] Check if vmail UID is available"
      shell: "id {{ vmail_uid }} 2>&1 | grep -q 'no such user' && echo 'available' || echo 'taken'"
      register: vmail_uid_check
      changed_when: false
      failed_when: false

    - name: "[PRE-FLIGHT] Display UID warning if taken"
      debug:
        msg: |
          WARNING: UID {{ vmail_uid }} is already in use
          This may cause permission conflicts with mail storage.
          Deployment will continue but may require manual intervention.
      when: vmail_uid_check.stdout == 'taken'

    - name: "[PRE-FLIGHT] Check for existing mail server components"
      shell: "dpkg -l 2>/dev/null | grep -E '^ii.*(postfix|dovecot)' | awk '{print $2}' || true"
      register: existing_mail_packages
      changed_when: false

    - name: "[PRE-FLIGHT] Display existing mail server warning"
      debug:
        msg: |
          ========================================
          WARNING: EXISTING MAIL SERVER DETECTED
          ========================================

          Found installed packages:
          {{ existing_mail_packages.stdout_lines | join('\n          ') }}

          iRedMail and most mail server deployments recommend a FRESH server.

          Potential Issues:
          - Configuration conflicts
          - Service binding conflicts
          - Data corruption or loss

          Recommendations:
          1. Back up any existing mail data
          2. Remove existing mail packages: apt remove postfix dovecot* --purge
          3. Verify clean state: dpkg -l | grep -E '(postfix|dovecot)'

          Deployment will continue in 10 seconds...
          Press Ctrl+C to abort if you need to clean up first.
          ========================================
      when: existing_mail_packages.stdout_lines | length > 0

    - name: "[PRE-FLIGHT] Pause if existing mail server detected"
      pause:
        seconds: 10
      when: existing_mail_packages.stdout_lines | length > 0

    - name: "[PRE-FLIGHT] Check required ports availability"
      wait_for:
        port: "{{ item.port }}"
        state: stopped
        timeout: 1
      loop:
        - { port: 25, name: 'SMTP' }
        - { port: 80, name: 'HTTP' }
        - { port: 110, name: 'POP3' }
        - { port: 143, name: 'IMAP' }
        - { port: 443, name: 'HTTPS' }
        - { port: 465, name: 'SMTPS' }
        - { port: 587, name: 'Submission' }
        - { port: 993, name: 'IMAPS' }
        - { port: 995, name: 'POP3S' }
        - { port: "{{ api_port }}", name: 'API' }
      ignore_errors: yes
      register: port_check

    - name: "[PRE-FLIGHT] Analyze port conflicts"
      set_fact:
        ports_in_use: "{{ port_check.results | selectattr('failed', 'equalto', true) | map(attribute='item') | list }}"

    - name: "[PRE-FLIGHT] Display port conflict warning"
      debug:
        msg: |
          ========================================
          WARNING: PORT CONFLICTS DETECTED
          ========================================

          The following ports are already in use:
          {% for port in ports_in_use %}
          - Port {{ port.port }} ({{ port.name }})
          {% endfor %}

          Common causes:
          - Existing web server (Apache, Nginx)
          - Existing mail server (Postfix, Dovecot)
          - Development servers

          To fix:
          1. Stop conflicting services:
             systemctl stop apache2 nginx postfix dovecot

          2. Identify process using port:
             lsof -i :{{ ports_in_use[0].port }}
             netstat -tulpn | grep :{{ ports_in_use[0].port }}

          Deployment will attempt to continue...
          ========================================
      when: ports_in_use | length > 0

    - name: "[PRE-FLIGHT] Stop conflicting services automatically"
      systemd:
        name: "{{ item }}"
        state: stopped
      loop:
        - apache2
        - nginx
      ignore_errors: yes
      when: ports_in_use | length > 0

    - name: "[PRE-FLIGHT] Validation summary"
      debug:
        msg: |
          ========================================
          PRE-FLIGHT VALIDATION SUMMARY
          ========================================

          System Resources:
          ✓ Memory: {{ ansible_memtotal_mb }} MB ({{ 'OK' if ansible_memtotal_mb >= 4096 else 'Adequate' if ansible_memtotal_mb >= 2048 else 'INSUFFICIENT' }})
          ✓ Disk Space: {{ (ansible_mounts | selectattr('mount', 'equalto', '/') | map(attribute='size_available') | first / 1024 / 1024 / 1024) | round(2) }} GB
          ✓ CPU Cores: {{ ansible_processor_vcpus }}

          Configuration:
          ✓ Domain: {{ domain }}
          ✓ Hostname: {{ hostname }}
          ✓ vmail UID: {{ vmail_uid }} ({{ 'available' if vmail_uid_check.stdout == 'available' else 'IN USE - may conflict' }})

          Network:
          ✓ Server IP: {{ ansible_default_ipv4.address }}
          ✓ DNS Automation: {{ 'Enabled (Cloudflare)' if cf_email is defined and cf_email | length > 0 else 'Disabled (Manual DNS required)' }}

          {{ 'All checks passed! Proceeding with deployment...' if existing_mail_packages.stdout_lines | length == 0 else 'Warnings present - review above before continuing' }}
          ========================================

  tasks:
    # ========== CONFIGURATION BACKUP (Phase 1 - Rollback Mechanism) ==========

    - name: "[BACKUP] Check if this is a re-deployment"
      stat:
        path: /etc/postfix/main.cf
      register: existing_postfix

    - name: "[BACKUP] Check if Dovecot exists"
      stat:
        path: /etc/dovecot/dovecot.conf
      register: existing_dovecot

    - name: "[BACKUP] Check if MySQL exists"
      stat:
        path: /etc/mysql/my.cnf
      register: existing_mysql

    - name: "[BACKUP] Set backup required flag"
      set_fact:
        backup_required: "{{ existing_postfix.stat.exists or existing_dovecot.stat.exists or existing_mysql.stat.exists }}"

    - name: "[BACKUP] Display backup status"
      debug:
        msg: |
          ========================================
          BACKUP STATUS
          ========================================
          Backup Required: {{ backup_required }}

          {% if backup_required %}
          Existing configurations detected:
          - Postfix: {{ 'YES' if existing_postfix.stat.exists else 'NO' }}
          - Dovecot: {{ 'YES' if existing_dovecot.stat.exists else 'NO' }}
          - MySQL: {{ 'YES' if existing_mysql.stat.exists else 'NO' }}

          A backup will be created before proceeding.
          {% else %}
          This appears to be a fresh installation.
          No backup needed.
          {% endif %}
          ========================================

    - name: "[BACKUP] Create backup directory"
      file:
        path: /root/.mailrice_backups
        state: directory
        mode: '0700'
      when: backup_required

    - name: "[BACKUP] Create configuration backup"
      block:
        - name: "[BACKUP] Create timestamped backup"
          archive:
            path:
              - /etc/postfix
              - /etc/dovecot
              - /etc/mysql
              - /etc/opendkim
              - /etc/nginx/sites-available
              - /var/vmail
            dest: /root/.mailrice_backups/backup_{{ ansible_date_time.epoch }}.tar.gz
            format: gz
          register: backup_archive

        - name: "[BACKUP] Store backup metadata"
          copy:
            dest: /root/.mailrice_backups/backup_{{ ansible_date_time.epoch }}.meta
            content: |
              Mailrice Backup Metadata
              ========================================
              Backup Created: {{ ansible_date_time.iso8601 }}
              Hostname: {{ ansible_hostname }}
              Domain: {{ domain }}
              Backup File: {{ backup_archive.dest }}

              Contents:
              - Postfix configuration
              - Dovecot configuration
              - MySQL configuration
              - OpenDKIM configuration
              - Nginx configuration
              - Mail data (/var/vmail)

              To restore this backup:
              sudo tar xzf {{ backup_archive.dest }} -C /

              WARNING: This will overwrite current configurations!
            mode: '0600'

        - name: "[BACKUP] Store backup path"
          set_fact:
            backup_file: "{{ backup_archive.dest }}"

        - name: "[BACKUP] Display backup confirmation"
          debug:
            msg: |
              ========================================
              BACKUP CREATED SUCCESSFULLY
              ========================================
              ✓ Backup created successfully
              Location: {{ backup_archive.dest }}

              This backup can be used to restore if deployment fails.
              ========================================

      rescue:
        - name: "[BACKUP] Handle backup failure"
          debug:
            msg: |
              ========================================
              BACKUP WARNING
              ========================================
              WARNING: Backup creation failed

              This is not critical for fresh installations.
              For re-deployments, consider manual backup:

              tar czf /root/manual_backup.tar.gz /etc/postfix /etc/dovecot /etc/mysql
              ========================================

        - name: "[BACKUP] Continue despite backup failure"
          set_fact:
            backup_file: ""

      when: backup_required

    - name: "[BACKUP] Keep last 5 backups only"
      shell: |
        cd /root/.mailrice_backups
        ls -t backup_*.tar.gz 2>/dev/null | tail -n +6 | xargs rm -f
        ls -t backup_*.meta 2>/dev/null | tail -n +6 | xargs rm -f
      args:
        executable: /bin/bash
      when: backup_required
      ignore_errors: yes

    # ========== END CONFIGURATION BACKUP ==========

    - name: Check if database password file exists
      stat:
        path: /root/.db_password
      register: db_password_file

    - name: Load existing database password
      command: cat /root/.db_password
      register: existing_password
      when: db_password_file.stat.exists
      changed_when: false

    - name: Set existing database password as fact
      set_fact:
        db_password: "{{ existing_password.stdout }}"
      when: db_password_file.stat.exists

    - name: Generate new database password only if needed
      set_fact:
        db_password: "{{ lookup('password', '/dev/null length=32 chars=ascii_letters,digits') }}"
      when: not db_password_file.stat.exists

    - name: Save database password for future deployments
      copy:
        content: "{{ db_password }}"
        dest: /root/.db_password
        mode: '0600'
      when: not db_password_file.stat.exists

    - name: Generate secure API key
      set_fact:
        initial_api_key: "{{ lookup('password', '/dev/null length=64 chars=ascii_letters,digits') }}"

    - name: Generate secure master API key
      set_fact:
        master_api_key: "{{ lookup('password', '/dev/null length=64 chars=ascii_letters,digits') }}"

    - name: Update apt cache
      apt:
        update_cache: yes
        cache_valid_time: 3600

    - name: "[INSTALL] Install required packages (with retry - Phase 1)"
      apt:
        name:
          - postfix
          - postfix-mysql
          - dovecot-core
          - dovecot-imapd
          - dovecot-pop3d
          - dovecot-lmtpd
          - dovecot-mysql
          - opendkim
          - opendkim-tools
          - mysql-server
          - python3-pymysql
          - nginx
          - curl
          - jq
          - certbot
          - python3-certbot-nginx
        state: present
      register: package_install
      until: package_install is succeeded
      retries: 3
      delay: 10

    - name: Install Node.js 20.x
      shell: |
        curl -fsSL https://deb.nodesource.com/setup_20.x | bash -
        apt-get install -y nodejs
      args:
        creates: /usr/bin/node

    - name: Create vmail group
      group:
        name: vmail
        gid: "{{ vmail_gid }}"
        system: yes

    - name: Create vmail user
      user:
        name: vmail
        uid: "{{ vmail_uid }}"
        group: vmail
        home: /var/vmail
        create_home: yes
        system: yes

    - name: Set /var/vmail permissions for group write access
      file:
        path: /var/vmail
        mode: '0770'
        owner: vmail
        group: vmail

    # ========== MySQL Configuration (iRedMail-inspired improvements) ==========

    - name: Ensure MySQL service is enabled and started
      systemd:
        name: mysql
        state: started
        enabled: yes

    - name: Wait for MySQL to be ready
      wait_for:
        port: 3306
        delay: 5
        timeout: 60
        host: 127.0.0.1

    - name: Create /root/.my.cnf for root authentication
      copy:
        content: |
          [client]
          user=root
          password=""
          socket=/var/run/mysqld/mysqld.sock
        dest: /root/.my.cnf
        mode: '0600'

    - name: Secure MySQL installation - Remove anonymous users and test database
      shell: |
        mysql -e "DELETE FROM mysql.user WHERE User='';" || true
        mysql -e "DELETE FROM mysql.user WHERE User='root' AND Host NOT IN ('localhost', '127.0.0.1', '::1');" || true
        mysql -e "DROP DATABASE IF EXISTS test;" || true
        mysql -e "DELETE FROM mysql.db WHERE Db='test' OR Db='test\\_%';" || true
        mysql -e "FLUSH PRIVILEGES;"
      args:
        executable: /bin/bash
      ignore_errors: yes

    - name: Create MySQL database
      mysql_db:
        name: "{{ db_name }}"
        state: present
        login_unix_socket: /var/run/mysqld/mysqld.sock

    - name: Create MySQL user with proper syntax
      shell: >
        mysql -e "DROP USER IF EXISTS '{{ db_user }}'@'localhost';" &&
        mysql -e "CREATE USER '{{ db_user }}'@'localhost' IDENTIFIED BY '{{ db_password }}';" &&
        mysql -e "GRANT ALL PRIVILEGES ON {{ db_name }}.* TO '{{ db_user }}'@'localhost';" &&
        mysql -e "FLUSH PRIVILEGES;"
      args:
        executable: /bin/bash

    - name: Copy database schema
      copy:
        src: templates/schema.sql
        dest: /tmp/schema.sql

    - name: Create database schema
      mysql_db:
        name: "{{ db_name }}"
        state: import
        target: /tmp/schema.sql
        login_unix_socket: /var/run/mysqld/mysqld.sock

    - name: Check if SPF/DMARC columns exist in virtual_domains table
      shell: >
        mysql -e "SHOW COLUMNS FROM virtual_domains LIKE 'spf_record';" {{ db_name }} | grep -q spf_record
      register: spf_column_check
      ignore_errors: yes
      changed_when: false

    - name: Add SPF/DMARC columns if missing (schema migration)
      shell: >
        mysql {{ db_name }} -e "ALTER TABLE virtual_domains
        ADD COLUMN spf_record TEXT AFTER dkim_public_key,
        ADD COLUMN dmarc_record TEXT AFTER spf_record,
        ADD COLUMN server_ip VARCHAR(45) AFTER dmarc_record;"
      when: spf_column_check.rc != 0
      ignore_errors: yes

    - name: Insert initial API key into database
      shell: |
        mysql {{ db_name }} -e "DELETE FROM api_keys WHERE description LIKE 'Default%' OR description = 'Initial API Key';" || true
        mysql {{ db_name }} -e "INSERT INTO api_keys (api_key, description) VALUES ('{{ initial_api_key }}', 'Initial API Key - Generated on deployment');"
      args:
        executable: /bin/bash

    - name: Configure Postfix main.cf
      template:
        src: templates/postfix-main.cf.j2
        dest: /etc/postfix/main.cf
        backup: yes
      notify: restart postfix

    - name: Configure Postfix master.cf
      blockinfile:
        path: /etc/postfix/master.cf
        block: |
          submission inet n       -       y       -       -       smtpd
            -o syslog_name=postfix/submission
            -o smtpd_tls_security_level=encrypt
            -o smtpd_sasl_auth_enable=yes
            -o smtpd_client_restrictions=permit_sasl_authenticated,reject

          smtps     inet  n       -       y       -       -       smtpd
            -o syslog_name=postfix/smtps
            -o smtpd_tls_wrappermode=yes
            -o smtpd_sasl_auth_enable=yes
            -o smtpd_client_restrictions=permit_sasl_authenticated,reject
      notify: restart postfix

    - name: Create Postfix MySQL config files
      template:
        src: "{{ item.src }}"
        dest: "{{ item.dest }}"
      loop:
        - { src: 'templates/mysql-virtual-mailbox-domains.cf.j2', dest: '/etc/postfix/mysql-virtual-mailbox-domains.cf' }
        - { src: 'templates/mysql-virtual-mailbox-maps.cf.j2', dest: '/etc/postfix/mysql-virtual-mailbox-maps.cf' }
        - { src: 'templates/mysql-virtual-alias-maps.cf.j2', dest: '/etc/postfix/mysql-virtual-alias-maps.cf' }
      notify: restart postfix

    - name: Configure Dovecot SQL
      template:
        src: templates/dovecot-sql.conf.ext.j2
        dest: /etc/dovecot/dovecot-sql.conf.ext
        mode: '0640'
        owner: root
        group: dovecot
      notify: restart dovecot

    - name: Configure Dovecot mail location
      lineinfile:
        path: /etc/dovecot/conf.d/10-mail.conf
        regexp: '^mail_location'
        line: 'mail_location = maildir:/var/vmail/%d/%n'
      notify: restart dovecot

    - name: Configure Dovecot auth
      lineinfile:
        path: /etc/dovecot/conf.d/10-auth.conf
        regexp: "{{ item.regexp }}"
        line: "{{ item.line }}"
      loop:
        - { regexp: '^!include auth-system.conf.ext', line: '#!include auth-system.conf.ext' }
        - { regexp: '^#!include auth-sql.conf.ext', line: '!include auth-sql.conf.ext' }
        - { regexp: '^#auth_mechanisms', line: 'auth_mechanisms = plain login' }
        - { regexp: '^#disable_plaintext_auth', line: 'disable_plaintext_auth = yes' }
      notify: restart dovecot

    - name: Configure Dovecot LMTP and auth services
      blockinfile:
        path: /etc/dovecot/conf.d/10-master.conf
        block: |
          service lmtp {
            unix_listener /var/spool/postfix/private/dovecot-lmtp {
              mode = 0600
              user = postfix
              group = postfix
            }
          }

          service auth {
            unix_listener /var/spool/postfix/private/auth {
              mode = 0660
              user = postfix
              group = postfix
            }
            unix_listener auth-userdb {
              mode = 0600
              user = vmail
            }
            user = dovecot
          }

          service auth-worker {
            user = vmail
          }
      notify: restart dovecot

    - name: Create mailapi system user
      user:
        name: mailapi
        system: yes
        create_home: no
        shell: /usr/sbin/nologin
        groups:
          - vmail
          - opendkim
        append: yes

    - name: Configure sudoers for mailapi
      copy:
        dest: /etc/sudoers.d/mailserver-api
        mode: '0440'
        content: |
          mailapi ALL=(ALL) NOPASSWD: /usr/sbin/opendkim-genkey
          mailapi ALL=(ALL) NOPASSWD: /usr/bin/opendkim-genkey
          mailapi ALL=(ALL) NOPASSWD: /bin/chown * /etc/opendkim/keys/*
          mailapi ALL=(ALL) NOPASSWD: /bin/chmod * /etc/opendkim/keys/*
          mailapi ALL=(ALL) NOPASSWD: /bin/chown * /var/vmail/*
          mailapi ALL=(ALL) NOPASSWD: /bin/systemctl reload opendkim
          mailapi ALL=(ALL) NOPASSWD: /bin/systemctl restart opendkim
          mailapi ALL=(ALL) NOPASSWD: /usr/bin/postqueue -p
          mailapi ALL=(ALL) NOPASSWD: /usr/bin/postqueue -f
          mailapi ALL=(ALL) NOPASSWD: /usr/bin/systemctl is-active *
          mailapi ALL=(ALL) NOPASSWD: /usr/bin/df *
          mailapi ALL=(ALL) NOPASSWD: /usr/bin/uptime
        validate: 'visudo -cf %s'

    - name: Create API directory
      file:
        path: /opt/mailserver-api
        state: directory
        mode: '0755'

    - name: Copy API files
      copy:
        src: "{{ item.src }}"
        dest: "{{ item.dest }}"
      loop:
        - { src: 'templates/server.js', dest: '/opt/mailserver-api/server.js' }
        - { src: 'templates/package.json', dest: '/opt/mailserver-api/package.json' }
        - { src: 'templates/db.js', dest: '/opt/mailserver-api/db.js' }
        - { src: 'templates/cache.js', dest: '/opt/mailserver-api/cache.js' }
        - { src: 'templates/health.js', dest: '/opt/mailserver-api/health.js' }
        - { src: 'templates/metrics.js', dest: '/opt/mailserver-api/metrics.js' }

    - name: Create API .env file
      template:
        src: templates/.env.j2
        dest: /opt/mailserver-api/.env

    - name: Install API dependencies
      npm:
        path: /opt/mailserver-api
        state: present

    - name: Set API directory ownership
      file:
        path: /opt/mailserver-api
        owner: mailapi
        group: mailapi
        recurse: yes

    - name: Ensure OpenDKIM directory exists
      file:
        path: /etc/opendkim
        state: directory
        owner: opendkim
        group: opendkim
        mode: '0755'

    - name: Ensure OpenDKIM keys directory exists
      file:
        path: /etc/opendkim/keys
        state: directory
        owner: opendkim
        group: opendkim
        mode: '0750'

    - name: Create OpenDKIM config files if they don't exist
      file:
        path: "{{ item }}"
        state: touch
        owner: opendkim
        group: opendkim
        mode: '0664'
        modification_time: preserve
        access_time: preserve
      loop:
        - /etc/opendkim/KeyTable
        - /etc/opendkim/SigningTable

    - name: Ensure OpenDKIM config files are writable by mailapi
      file:
        path: "{{ item }}"
        owner: opendkim
        group: opendkim
        mode: '0664'
      loop:
        - /etc/opendkim/KeyTable
        - /etc/opendkim/SigningTable

    - name: Set OpenDKIM directory permissions for group write access
      file:
        path: /etc/opendkim
        state: directory
        owner: opendkim
        group: opendkim
        mode: '0775'
        recurse: yes

    - name: Create systemd service for API
      template:
        src: templates/mailserver-api.service.j2
        dest: /etc/systemd/system/mailserver-api.service
      notify: restart mailserver-api

    # ============================================================================
    # PHASE 2: PERFORMANCE & MONITORING (Redis + Prometheus + Grafana)
    # ============================================================================

    - name: "[PERF] Install Redis server"
      apt:
        name:
          - redis-server
          - redis-tools
        state: present
        update_cache: yes

    - name: "[PERF] Configure Redis for performance"
      lineinfile:
        path: /etc/redis/redis.conf
        regexp: "{{ item.regexp }}"
        line: "{{ item.line }}"
        backup: yes
      loop:
        - { regexp: '^maxmemory ', line: 'maxmemory 256mb' }
        - { regexp: '^maxmemory-policy ', line: 'maxmemory-policy allkeys-lru' }
        - { regexp: '^# *save ', line: '# save disabled for performance' }
      notify: restart redis

    - name: "[PERF] Start and enable Redis"
      systemd:
        name: redis-server
        state: started
        enabled: yes

    - name: "[PERF] Add database indexes for performance"
      community.mysql.mysql_query:
        login_unix_socket: /var/run/mysqld/mysqld.sock
        login_db: mailserver
        query: |
          CREATE INDEX IF NOT EXISTS idx_domain ON virtual_domains(name);
          CREATE INDEX IF NOT EXISTS idx_email ON virtual_users(email);
          CREATE INDEX IF NOT EXISTS idx_domain_mailboxes ON virtual_users(domain_id);
          CREATE INDEX IF NOT EXISTS idx_api_key ON api_keys(api_key);
          CREATE INDEX IF NOT EXISTS idx_active_users ON virtual_users(active);
          ANALYZE TABLE virtual_domains;
          ANALYZE TABLE virtual_users;
          ANALYZE TABLE api_keys;

    - name: "[MONITOR] Create prometheus system user"
      user:
        name: prometheus
        system: yes
        shell: /bin/false
        create_home: no

    - name: "[MONITOR] Download and install Prometheus"
      unarchive:
        src: "https://github.com/prometheus/prometheus/releases/download/v2.45.0/prometheus-2.45.0.linux-amd64.tar.gz"
        dest: /opt
        remote_src: yes
        creates: /opt/prometheus-2.45.0.linux-amd64

    - name: "[MONITOR] Create Prometheus symlink"
      file:
        src: /opt/prometheus-2.45.0.linux-amd64
        dest: /opt/prometheus
        state: link

    - name: "[MONITOR] Create Prometheus directories"
      file:
        path: "{{ item }}"
        state: directory
        owner: prometheus
        group: prometheus
        mode: '0755'
      loop:
        - /etc/prometheus
        - /etc/prometheus/rules
        - /var/lib/prometheus

    - name: "[MONITOR] Copy Prometheus configuration"
      template:
        src: templates/prometheus.yml.j2
        dest: /etc/prometheus/prometheus.yml
        owner: prometheus
        group: prometheus
        mode: '0644'
      notify: restart prometheus

    - name: "[MONITOR] Copy Prometheus alert rules"
      copy:
        src: templates/alert_rules.yml
        dest: /etc/prometheus/rules/alert_rules.yml
        owner: prometheus
        group: prometheus
        mode: '0644'
      notify: restart prometheus

    - name: "[MONITOR] Create Prometheus systemd service"
      copy:
        content: |
          [Unit]
          Description=Prometheus Monitoring System
          Documentation=https://prometheus.io/docs/introduction/overview/
          After=network.target

          [Service]
          Type=simple
          User=prometheus
          Group=prometheus
          ExecStart=/opt/prometheus/prometheus \
            --config.file=/etc/prometheus/prometheus.yml \
            --storage.tsdb.path=/var/lib/prometheus/ \
            --web.listen-address=:9090 \
            --storage.tsdb.retention.time=30d \
            --web.console.templates=/opt/prometheus/consoles \
            --web.console.libraries=/opt/prometheus/console_libraries
          Restart=always
          RestartSec=5

          [Install]
          WantedBy=multi-user.target
        dest: /etc/systemd/system/prometheus.service
        mode: '0644'
      notify: reload systemd

    - name: "[MONITOR] Start and enable Prometheus"
      systemd:
        name: prometheus
        state: started
        enabled: yes
        daemon_reload: yes

    - name: "[MONITOR] Download and install Node Exporter"
      unarchive:
        src: "https://github.com/prometheus/node_exporter/releases/download/v1.6.1/node_exporter-1.6.1.linux-amd64.tar.gz"
        dest: /opt
        remote_src: yes
        creates: /opt/node_exporter-1.6.1.linux-amd64

    - name: "[MONITOR] Create Node Exporter symlink"
      file:
        src: /opt/node_exporter-1.6.1.linux-amd64
        dest: /opt/node_exporter
        state: link

    - name: "[MONITOR] Create Node Exporter systemd service"
      copy:
        content: |
          [Unit]
          Description=Node Exporter
          After=network.target

          [Service]
          Type=simple
          User=prometheus
          ExecStart=/opt/node_exporter/node_exporter \
            --collector.filesystem.mount-points-exclude=^/(dev|proc|sys|var/lib/docker/.+)($|/) \
            --collector.netclass.ignored-devices=^(veth.*|docker.*|br.*)$
          Restart=always

          [Install]
          WantedBy=multi-user.target
        dest: /etc/systemd/system/node_exporter.service
        mode: '0644'
      notify: reload systemd

    - name: "[MONITOR] Start and enable Node Exporter"
      systemd:
        name: node_exporter
        state: started
        enabled: yes
        daemon_reload: yes

    - name: "[MONITOR] Download and install Redis Exporter"
      get_url:
        url: "https://github.com/oliver006/redis_exporter/releases/download/v1.55.0/redis_exporter-v1.55.0.linux-amd64.tar.gz"
        dest: /tmp/redis_exporter.tar.gz

    - name: "[MONITOR] Extract Redis Exporter"
      unarchive:
        src: /tmp/redis_exporter.tar.gz
        dest: /opt
        remote_src: yes
        creates: /opt/redis_exporter-v1.55.0.linux-amd64

    - name: "[MONITOR] Create Redis Exporter symlink"
      file:
        src: /opt/redis_exporter-v1.55.0.linux-amd64/redis_exporter
        dest: /usr/local/bin/redis_exporter
        state: link

    - name: "[MONITOR] Create Redis Exporter systemd service"
      copy:
        content: |
          [Unit]
          Description=Redis Exporter
          After=network.target redis.service

          [Service]
          Type=simple
          User=prometheus
          ExecStart=/usr/local/bin/redis_exporter \
            --redis.addr=localhost:6379 \
            --web.listen-address=:9121
          Restart=always

          [Install]
          WantedBy=multi-user.target
        dest: /etc/systemd/system/redis_exporter.service
        mode: '0644'
      notify: reload systemd

    - name: "[MONITOR] Start and enable Redis Exporter"
      systemd:
        name: redis_exporter
        state: started
        enabled: yes
        daemon_reload: yes

    - name: "[MONITOR] Download and install MySQL Exporter"
      get_url:
        url: "https://github.com/prometheus/mysqld_exporter/releases/download/v0.15.0/mysqld_exporter-0.15.0.linux-amd64.tar.gz"
        dest: /tmp/mysqld_exporter.tar.gz

    - name: "[MONITOR] Extract MySQL Exporter"
      unarchive:
        src: /tmp/mysqld_exporter.tar.gz
        dest: /opt
        remote_src: yes
        creates: /opt/mysqld_exporter-0.15.0.linux-amd64

    - name: "[MONITOR] Create MySQL Exporter symlink"
      file:
        src: /opt/mysqld_exporter-0.15.0.linux-amd64/mysqld_exporter
        dest: /usr/local/bin/mysqld_exporter
        state: link

    - name: "[MONITOR] Create MySQL Exporter config"
      copy:
        content: |
          [client]
          user=root
          socket=/var/run/mysqld/mysqld.sock
        dest: /etc/.mysqld_exporter.cnf
        owner: prometheus
        group: prometheus
        mode: '0600'

    - name: "[MONITOR] Create MySQL Exporter systemd service"
      copy:
        content: |
          [Unit]
          Description=MySQL Exporter
          After=network.target mariadb.service

          [Service]
          Type=simple
          User=prometheus
          ExecStart=/usr/local/bin/mysqld_exporter \
            --config.my-cnf=/etc/.mysqld_exporter.cnf \
            --web.listen-address=:9104
          Restart=always

          [Install]
          WantedBy=multi-user.target
        dest: /etc/systemd/system/mysqld_exporter.service
        mode: '0644'
      notify: reload systemd

    - name: "[MONITOR] Start and enable MySQL Exporter"
      systemd:
        name: mysqld_exporter
        state: started
        enabled: yes
        daemon_reload: yes

    - name: "[MONITOR] Add Grafana APT key"
      apt_key:
        url: https://packages.grafana.com/gpg.key
        state: present

    - name: "[MONITOR] Add Grafana repository"
      apt_repository:
        repo: "deb https://packages.grafana.com/oss/deb stable main"
        state: present
        filename: grafana

    - name: "[MONITOR] Install Grafana"
      apt:
        name: grafana
        state: present
        update_cache: yes

    - name: "[MONITOR] Configure Grafana"
      template:
        src: templates/grafana.ini.j2
        dest: /etc/grafana/grafana.ini
        owner: root
        group: grafana
        mode: '0640'
      notify: restart grafana

    - name: "[MONITOR] Start and enable Grafana"
      systemd:
        name: grafana-server
        state: started
        enabled: yes

    - name: "[MONITOR] Wait for Grafana to start"
      wait_for:
        port: 3001
        delay: 5
        timeout: 60

    - name: "[MONITOR] Add Prometheus datasource to Grafana"
      uri:
        url: http://localhost:3001/api/datasources
        method: POST
        user: admin
        password: "{{ db_password }}"
        force_basic_auth: yes
        body_format: json
        body:
          name: "Prometheus"
          type: "prometheus"
          url: "http://localhost:9090"
          access: "proxy"
          isDefault: true
        status_code: [200, 409]
      ignore_errors: yes

    # ============================================================================
    # END PHASE 2
    # ============================================================================

    - name: Create Dashboard directory
      file:
        path: /opt/mailserver-dashboard
        state: directory
        mode: '0755'

    - name: Create Dashboard subdirectories
      file:
        path: "{{ item }}"
        state: directory
        mode: '0755'
      loop:
        - /opt/mailserver-dashboard/css
        - /opt/mailserver-dashboard/js

    - name: Copy Dashboard HTML files
      copy:
        src: "{{ item.src }}"
        dest: "{{ item.dest }}"
        mode: '0644'
      loop:
        - { src: 'templates/dashboard.html', dest: '/opt/mailserver-dashboard/index.html' }
        - { src: 'templates/login.html', dest: '/opt/mailserver-dashboard/login.html' }

    - name: Copy Dashboard CSS
      copy:
        src: templates/dashboard.css
        dest: /opt/mailserver-dashboard/css/dashboard.css
        mode: '0644'

    - name: Copy Dashboard JavaScript
      copy:
        src: templates/dashboard.js
        dest: /opt/mailserver-dashboard/js/dashboard.js
        mode: '0644'

    - name: Create Documentation directory
      file:
        path: /opt/mailserver-dashboard/docs
        state: directory
        mode: '0755'

    - name: Copy Documentation files
      copy:
        src: templates/docs/
        dest: /opt/mailserver-dashboard/docs/
        mode: '0644'

    - name: Create webroot directory for SSL certificate acquisition
      file:
        path: /var/www/html
        state: directory
        mode: '0755'

    # Clean up any existing SSL-enabled nginx configs from previous deployments
    # This prevents nginx from failing to start when SSL certs don't exist yet
    - name: Disable Dashboard Nginx site if exists (cleanup from previous deployment)
      file:
        path: /etc/nginx/sites-enabled/mailserver-dashboard
        state: absent
      ignore_errors: yes

    - name: Disable API Nginx site if exists (cleanup from previous deployment)
      file:
        path: /etc/nginx/sites-enabled/mailserver-api
        state: absent
      ignore_errors: yes

    - name: Create DNS A record for mail hostname via Cloudflare
      uri:
        url: "https://api.cloudflare.com/client/v4/zones/{{ cf_zone_id }}/dns_records"
        method: POST
        headers:
          X-Auth-Email: "{{ cf_email }}"
          X-Auth-Key: "{{ cf_api_key }}"
          Content-Type: "application/json"
        body_format: json
        body:
          type: "A"
          name: "{{ hostname }}"
          content: "{{ ansible_default_ipv4.address }}"
          ttl: 120
          proxied: false
        status_code: [200, 201]
      when: cf_email is defined and cf_email | length > 0 and cf_api_key is defined and cf_api_key | length > 0 and cf_zone_id is defined and cf_zone_id | length > 0
      ignore_errors: yes
      register: dns_hostname_result

    - name: Create DNS A record for dashboard subdomain via Cloudflare
      uri:
        url: "https://api.cloudflare.com/client/v4/zones/{{ cf_zone_id }}/dns_records"
        method: POST
        headers:
          X-Auth-Email: "{{ cf_email }}"
          X-Auth-Key: "{{ cf_api_key }}"
          Content-Type: "application/json"
        body_format: json
        body:
          type: "A"
          name: "wow.{{ domain }}"
          content: "{{ ansible_default_ipv4.address }}"
          ttl: 120
          proxied: false
        status_code: [200, 201]
      when: cf_email is defined and cf_email | length > 0 and cf_api_key is defined and cf_api_key | length > 0 and cf_zone_id is defined and cf_zone_id | length > 0
      ignore_errors: yes
      register: dns_dashboard_result

    - name: Wait for DNS propagation
      pause:
        seconds: 30
      when: (dns_hostname_result is changed or dns_dashboard_result is changed) and (dns_hostname_result is not failed and dns_dashboard_result is not failed)

    - name: Create temporary HTTP-only nginx config for certbot
      copy:
        dest: /etc/nginx/sites-available/certbot-temp
        content: |
          server {
              listen 80 default_server;
              listen [::]:80 default_server;
              server_name {{ hostname }} wow.{{ domain }};
              root /var/www/html;

              location / {
                  return 200 'OK';
                  add_header Content-Type text/plain;
              }

              location /.well-known/acme-challenge/ {
                  root /var/www/html;
              }
          }
        mode: '0644'
      notify: restart nginx

    - name: Enable temporary nginx config
      file:
        src: /etc/nginx/sites-available/certbot-temp
        dest: /etc/nginx/sites-enabled/certbot-temp
        state: link
      notify: restart nginx

    - name: Remove default Nginx site
      file:
        path: /etc/nginx/sites-enabled/default
        state: absent
      notify: restart nginx

    - name: Force Nginx restart before SSL certificate acquisition
      meta: flush_handlers

    - name: Wait for Nginx to be ready
      wait_for:
        port: 80
        timeout: 30

    - name: "[SSL] Obtain Let's Encrypt SSL certificate for mail hostname (with retry - Phase 1)"
      shell: |
        certbot certonly --webroot \
          -w /var/www/html \
          --non-interactive \
          --agree-tos \
          --email postmaster@{{ domain }} \
          --domains {{ hostname }} \
          --keep-until-expiring
      args:
        creates: /etc/letsencrypt/live/{{ hostname }}/fullchain.pem
      register: certbot_result
      until: certbot_result.rc == 0
      retries: 3
      delay: 30
      ignore_errors: yes

    - name: "[SSL] Obtain Let's Encrypt SSL certificate for dashboard (with retry - Phase 1)"
      shell: |
        certbot certonly --webroot \
          -w /var/www/html \
          --non-interactive \
          --agree-tos \
          --email postmaster@{{ domain }} \
          --domains wow.{{ domain }} \
          --keep-until-expiring
      args:
        creates: /etc/letsencrypt/live/wow.{{ domain }}/fullchain.pem
      register: certbot_dashboard_result
      until: certbot_dashboard_result.rc == 0
      retries: 3
      delay: 30
      ignore_errors: yes

    - name: Configure Nginx for Dashboard subdomain
      template:
        src: templates/nginx-dashboard.conf.j2
        dest: /etc/nginx/sites-available/mailserver-dashboard
      notify: restart nginx
      when: certbot_dashboard_result is succeeded

    - name: Enable Dashboard Nginx site
      file:
        src: /etc/nginx/sites-available/mailserver-dashboard
        dest: /etc/nginx/sites-enabled/mailserver-dashboard
        state: link
      notify: restart nginx
      when: certbot_dashboard_result is succeeded

    - name: Configure Nginx reverse proxy for API
      template:
        src: templates/nginx-api.conf.j2
        dest: /etc/nginx/sites-available/mailserver-api
      notify: restart nginx
      when: certbot_result is succeeded

    - name: Enable Nginx site
      file:
        src: /etc/nginx/sites-available/mailserver-api
        dest: /etc/nginx/sites-enabled/mailserver-api
        state: link
      notify: restart nginx
      when: certbot_result is succeeded

    - name: Reload Nginx after SSL certificate acquisition
      systemd:
        name: nginx
        state: reloaded
      when: (certbot_result is succeeded or certbot_dashboard_result is succeeded) and (certbot_result is changed or certbot_dashboard_result is changed)
      ignore_errors: yes

    - name: Remove temporary certbot nginx config
      file:
        path: /etc/nginx/sites-enabled/certbot-temp
        state: absent
      when: certbot_result is succeeded or certbot_dashboard_result is succeeded
      notify: reload nginx

    - name: Create certbot renewal hook directory
      file:
        path: /etc/letsencrypt/renewal-hooks/deploy
        state: directory
        mode: '0755'
      when: certbot_result is succeeded

    - name: Create renewal hook script
      copy:
        dest: /etc/letsencrypt/renewal-hooks/deploy/reload-mail-services.sh
        mode: '0755'
        content: |
          #!/bin/bash
          systemctl reload postfix dovecot nginx
      when: certbot_result is succeeded

    - name: Update Postfix to use Let's Encrypt certificates
      lineinfile:
        path: /etc/postfix/main.cf
        regexp: "{{ item.regexp }}"
        line: "{{ item.line }}"
      loop:
        - { regexp: '^smtpd_tls_cert_file', line: 'smtpd_tls_cert_file = /etc/letsencrypt/live/{{ hostname }}/fullchain.pem' }
        - { regexp: '^smtpd_tls_key_file', line: 'smtpd_tls_key_file = /etc/letsencrypt/live/{{ hostname }}/privkey.pem' }
      when: certbot_result is succeeded
      notify: restart postfix

    - name: Configure Dovecot SSL
      blockinfile:
        path: /etc/dovecot/conf.d/10-ssl.conf
        create: yes
        block: |
          ssl = required
          ssl_cert = </etc/letsencrypt/live/{{ hostname }}/fullchain.pem
          ssl_key = </etc/letsencrypt/live/{{ hostname }}/privkey.pem
          ssl_min_protocol = TLSv1.2
          ssl_cipher_list = HIGH:!aNULL:!MD5
          ssl_prefer_server_ciphers = yes
      when: certbot_result is succeeded
      notify: restart dovecot

    - name: Reload systemd daemon
      systemd:
        daemon_reload: yes

    - name: Install UFW firewall
      apt:
        name: ufw
        state: present

    - name: Configure UFW - Allow SSH
      ufw:
        rule: allow
        port: '22'
        proto: tcp

    - name: Configure UFW - Allow HTTP
      ufw:
        rule: allow
        port: '80'
        proto: tcp

    - name: Configure UFW - Allow HTTPS
      ufw:
        rule: allow
        port: '443'
        proto: tcp

    - name: Configure UFW - Allow SMTP
      ufw:
        rule: allow
        port: '25'
        proto: tcp

    - name: Configure UFW - Allow SMTP Submission
      ufw:
        rule: allow
        port: '587'
        proto: tcp

    - name: Configure UFW - Allow SMTPS
      ufw:
        rule: allow
        port: '465'
        proto: tcp

    - name: Configure UFW - Allow IMAP
      ufw:
        rule: allow
        port: '143'
        proto: tcp

    - name: Configure UFW - Allow IMAPS
      ufw:
        rule: allow
        port: '993'
        proto: tcp

    - name: Configure UFW - Allow POP3
      ufw:
        rule: allow
        port: '110'
        proto: tcp

    - name: Configure UFW - Allow POP3S
      ufw:
        rule: allow
        port: '995'
        proto: tcp

    - name: Configure UFW - Allow API port
      ufw:
        rule: allow
        port: "{{ api_port }}"
        proto: tcp

    - name: Enable UFW
      ufw:
        state: enabled
        policy: deny

    - name: Install Fail2ban
      apt:
        name: fail2ban
        state: present

    - name: Create Fail2ban jail for Postfix
      copy:
        dest: /etc/fail2ban/jail.d/postfix.conf
        content: |
          [postfix]
          enabled = true
          port = smtp,465,587
          filter = postfix
          logpath = /var/log/mail.log
          maxretry = 5
          bantime = 3600
          findtime = 600

          [postfix-sasl]
          enabled = true
          port = smtp,465,587
          filter = postfix-sasl
          logpath = /var/log/mail.log
          maxretry = 3
          bantime = 3600
          findtime = 600
      notify: restart fail2ban

    - name: Create Fail2ban jail for Dovecot
      copy:
        dest: /etc/fail2ban/jail.d/dovecot.conf
        content: |
          [dovecot]
          enabled = true
          port = pop3,pop3s,imap,imaps
          filter = dovecot
          logpath = /var/log/mail.log
          maxretry = 3
          bantime = 3600
          findtime = 600
      notify: restart fail2ban

    - name: Create Fail2ban jail for SSH
      copy:
        dest: /etc/fail2ban/jail.d/sshd.conf
        content: |
          [sshd]
          enabled = true
          port = ssh
          logpath = /var/log/auth.log
          maxretry = 5
          bantime = 3600
          findtime = 600
      notify: restart fail2ban

    - name: Create Fail2ban jail for Nginx
      copy:
        dest: /etc/fail2ban/jail.d/nginx.conf
        content: |
          [nginx-http-auth]
          enabled = true
          port = http,https
          logpath = /var/log/nginx/error.log
          maxretry = 3
          bantime = 3600
          findtime = 600

          [nginx-limit-req]
          enabled = true
          port = http,https
          logpath = /var/log/nginx/error.log
          maxretry = 10
          bantime = 600
          findtime = 600
      notify: restart fail2ban

    - name: Enable and start Fail2ban
      systemd:
        name: fail2ban
        enabled: yes
        state: started

    - name: Enable and start services
      systemd:
        name: "{{ item }}"
        enabled: yes
        state: started
      loop:
        - opendkim
        - postfix
        - dovecot
        - mailserver-api
        - nginx

    - name: "[API] Wait for API to be ready (extended retry - Phase 1)"
      uri:
        url: "http://localhost:{{ api_port }}/health"
        method: GET
        status_code: 200
      register: api_health
      until: api_health.status == 200
      retries: 60
      delay: 2

    # ========== CENTRALIZED LOGGING - Service Logs (Phase 1) ==========

    - name: "[LOGGING] Create Mailrice log directory"
      file:
        path: /var/log/mailrice
        state: directory
        mode: '0755'

    - name: "[LOGGING] Configure rsyslog for mail services"
      copy:
        dest: /etc/rsyslog.d/10-mailrice.conf
        content: |
          # Mailrice Centralized Logging Configuration (Phase 1 - V2 Stabalisation)
          # Routes mail service logs to dedicated files

          # Postfix logs
          :programname, isequal, "postfix" -/var/log/mailrice/postfix.log
          & stop

          # Dovecot logs
          :programname, isequal, "dovecot" -/var/log/mailrice/dovecot.log
          & stop

          # OpenDKIM logs
          :programname, isequal, "opendkim" -/var/log/mailrice/opendkim.log
          & stop
        mode: '0644'
      notify: restart rsyslog

    - name: "[LOGGING] Configure log rotation for Mailrice logs"
      copy:
        dest: /etc/logrotate.d/mailrice
        content: |
          # Mailrice Log Rotation Configuration
          # Keeps 14 days of logs, compressed

          /var/log/mailrice/*.log {
              daily
              rotate 14
              compress
              delaycompress
              notifempty
              missingok
              sharedscripts
              postrotate
                  systemctl reload rsyslog > /dev/null 2>&1 || true
              endscript
          }
        mode: '0644'

    - name: "[LOGGING] Create initial empty log files with correct permissions"
      file:
        path: "/var/log/mailrice/{{ item }}"
        state: touch
        mode: '0644'
      loop:
        - postfix.log
        - dovecot.log
        - opendkim.log
        - deployment.log
      changed_when: false

    # ========== END CENTRALIZED LOGGING ==========

    - name: Create initial admin domain via API
      uri:
        url: "http://localhost:{{ api_port }}/domains"
        method: POST
        headers:
          x-api-key: "{{ initial_api_key }}"
          Content-Type: "application/json"
        body_format: json
        body:
          domain: "{{ domain }}"
          dkim_selector: "mail"
        status_code: [201, 409]
      register: domain_creation
      ignore_errors: yes

    - name: Get DNS records for admin domain
      uri:
        url: "http://localhost:{{ api_port }}/domains/{{ domain }}/dns"
        method: GET
        headers:
          x-api-key: "{{ initial_api_key }}"
        return_content: yes
      register: dns_records
      when: domain_creation.status == 201 or domain_creation.status == 409

    - name: Save DNS records to file
      copy:
        dest: /root/.mailserver_dns_records
        mode: '0600'
        content: |
          ========================================
          DNS Records for {{ domain }}
          ========================================

          {{ dns_records.json.dns_records | to_nice_json }}

          ========================================
          Copy these records to your DNS provider
          ========================================
      when: dns_records is defined and dns_records.json is defined

    - name: Save API credentials to file
      copy:
        dest: /root/.mailserver_credentials
        mode: '0600'
        content: |
          ========================================
          Mailrice Server Credentials
          ========================================
          Generated: {{ ansible_date_time.iso8601 }}

          Initial API Key: {{ initial_api_key }}
          Master API Key: {{ master_api_key }}
          Database Password: {{ db_password }}

          ========================================

    - name: Display completion message
      debug:
        msg: |
          ========================================
          🎉 Mailrice Deployment Complete!
          ========================================
          Domain: {{ domain }}
          Mail Hostname: {{ hostname }}
          Dashboard URL: https://wow.{{ domain }}
          API URL: http://{{ ansible_default_ipv4.address }}:{{ api_port }}
          Server IP: {{ ansible_default_ipv4.address }}

          🔐 CREDENTIALS (saved to /root/.mailserver_credentials):
          ========================================
          Dashboard Login: Use Initial API Key below
          Initial API Key: {{ initial_api_key }}
          Master API Key: {{ master_api_key }}
          DB Password: {{ db_password }}
          ========================================

          📋 DNS RECORDS FOR {{ domain }} (saved to /root/.mailserver_dns_records):
          ========================================
          {% if dns_records is defined and dns_records.json is defined %}
          DKIM: {{ dns_records.json.dns_records.dkim }}
          SPF:  {{ dns_records.json.dns_records.spf }}
          DMARC: {{ dns_records.json.dns_records.dmarc }}
          {% else %}
          Run: curl http://{{ ansible_default_ipv4.address }}:{{ api_port }}/domains/{{ domain }}/dns -H "x-api-key: {{ initial_api_key }}"
          {% endif %}
          ========================================

          🌐 REQUIRED DNS RECORDS:
          ========================================
          1. A Record: {{ hostname }} → {{ ansible_default_ipv4.address }}
          2. A Record: wow.{{ domain }} → {{ ansible_default_ipv4.address }}
          3. Add the DKIM, SPF, and DMARC records shown above
          ========================================

          📧 Next Steps:
          ========================================
          1. Add all DNS records above to your DNS provider
          2. Wait 5-10 minutes for DNS propagation
          3. Access dashboard: https://wow.{{ domain }}
          4. Login with your Initial API Key
          5. Create your first mailbox via dashboard
          6. Start sending emails!

          🚀 Quick Actions:
          ========================================
          Access Dashboard:
            https://wow.{{ domain }}

          Create mailbox (API):
            curl -X POST http://{{ ansible_default_ipv4.address }}:{{ api_port }}/mailboxes \
              -H "x-api-key: {{ initial_api_key }}" \
              -H "Content-Type: application/json" \
              -d '{"email":"sender@{{ domain }}","password":"YourSecurePass123!","quota_mb":1000}'

          Generate additional API keys:
            curl -X POST http://{{ ansible_default_ipv4.address }}:{{ api_port }}/api-keys \
              -H "Content-Type: application/json" \
              -d '{"master_key":"{{ master_api_key }}","description":"My App"}'

          View DNS records:
            curl http://{{ ansible_default_ipv4.address }}:{{ api_port }}/domains/{{ domain }}/dns \
              -H "x-api-key: {{ initial_api_key }}"
          ========================================

          📚 Documentation:
          GitHub: https://github.com/Ayushjain101/Mailrice
          ========================================

  handlers:
    - name: restart postfix
      systemd:
        name: postfix
        state: restarted

    - name: restart dovecot
      systemd:
        name: dovecot
        state: restarted

    - name: restart mailserver-api
      systemd:
        name: mailserver-api
        state: restarted

    - name: restart nginx
      systemd:
        name: nginx
        state: restarted

    - name: restart rsyslog
      systemd:
        name: rsyslog
        state: restarted

    - name: restart redis
      systemd:
        name: redis-server
        state: restarted

    - name: restart prometheus
      systemd:
        name: prometheus
        state: restarted

    - name: restart grafana
      systemd:
        name: grafana-server
        state: restarted

    - name: rollback deployment
      block:
        - name: "[ROLLBACK] Stop all services"
          systemd:
            name: "{{ item }}"
            state: stopped
          loop:
            - postfix
            - dovecot
            - opendkim
            - nginx
            - mailserver-api
          ignore_errors: yes

        - name: "[ROLLBACK] Restore from backup"
          unarchive:
            src: "{{ backup_file }}"
            dest: /
            remote_src: yes
          when: backup_file is defined and backup_file | length > 0

        - name: "[ROLLBACK] Restart services"
          systemd:
            name: "{{ item }}"
            state: started
          loop:
            - mysql
            - postfix
            - dovecot
            - opendkim
            - nginx
            - mailserver-api
          ignore_errors: yes

        - name: "[ROLLBACK] Log rollback action"
          shell: |
            logger -t mailrice-deploy "ROLLBACK executed - restored from {{ backup_file | default('unknown') }}"
            echo "[$(date)] ROLLBACK - Deployment failed, restored from backup" >> /var/log/mailrice/deployment.log

        - name: "[ROLLBACK] Display rollback message"
          debug:
            msg: |
              ========================================
              DEPLOYMENT ROLLED BACK
              ========================================

              A deployment error occurred and the system
              has been restored to its previous state.

              Backup restored from: {{ backup_file | default('N/A') }}

              Next steps:
              1. Review deployment logs: /var/log/mailrice/
              2. Fix the underlying issue
              3. Re-run deployment

              ========================================

      when: backup_file is defined

    - name: reload nginx
      systemd:
        name: nginx
        state: reloaded

    - name: restart fail2ban
      systemd:
        name: fail2ban
        state: restarted
